//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t blank_line(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t driver_ping(void);
int64_t driver_post(char * a1, char * a2, int64_t * a3, int64_t a4, int64_t * a5);
int64_t explode_bomb(void);
int64_t frame_dummy(void);
int64_t fun7(int64_t a1, int64_t a2);
int64_t func4(int64_t a1, int64_t a2, int64_t a3);
char * function_1030(char * name);
int32_t * function_1040(void);
char * function_1050(char * dest, char * src);
int32_t function_1060(char * s);
int32_t function_1070(int32_t fd, int64_t * buf, int32_t n);
void function_1080(void);
int32_t function_1090(int32_t seconds);
int32_t function_10a0(int32_t fd);
int32_t function_10b0(int32_t fd, int64_t * buf, int32_t nbytes);
char * function_10c0(char * s, int32_t n, struct _IO_FILE * stream);
void (*function_10d0(int32_t sig, void (*handler)(int32_t)))(int32_t);
struct hostent * function_10e0(char * name);
int64_t * function_10f0(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen);
int32_t function_1100(char * nptr, char ** endptr, int32_t base);
int32_t function_1110(struct _IO_FILE * stream);
int32_t function_1120(char * s, char * format, ...);
int32_t function_1130(int32_t flag, char * format, ...);
struct _IO_FILE * function_1140(char * filename, char * modes);
void function_1150(int32_t status);
int32_t function_1160(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1170(struct _IO_FILE * stream, int32_t flag, char * format, ...);
int32_t function_1180(int32_t seconds);
int16_t ** function_1190(void);
int32_t function_11a0(char * s, int32_t flag, int32_t slen, char * format, ...);
int32_t function_11b0(int32_t domain, int32_t type, int32_t protocol);
void function_11c0(int64_t * d);
int64_t init_driver(int64_t * a1);
int64_t init_timeout(int64_t a1);
int64_t initialize_bomb(void);
int64_t initialize_bomb_solve(void);
int64_t invalid_phase(int64_t a1);
int64_t phase_1(void);
int64_t phase_2(void);
int64_t phase_3(int64_t a1, int64_t a2, int64_t a3);
int64_t phase_4(void);
int64_t phase_5(int64_t a1);
int64_t phase_6(void);
int64_t phase_defused(void);
int64_t read_line(void);
int64_t read_six_numbers(int64_t str, int64_t * a2);
int64_t register_tm_clones(void);
int64_t rio_readlineb(int64_t a1, int64_t a2, uint64_t a3);
int64_t secret_phase(void);
int64_t send_msg(int64_t a1);
int64_t sig_handler(void);
int64_t sigalrm_handler(void);
int64_t skip(void);
int64_t string_length(int64_t a1);
int64_t strings_not_equal(int64_t a1, char * a2);
int64_t submitr(char * name, int64_t * a2, char * a3, int64_t a4, int64_t a5, char * a6, int64_t a7, int64_t str2);
int64_t test_connection(void);

// --------------------- Global Variables ---------------------

int32_t * g1 = (int32_t *)-0x1c8400001c8c; // 0x31a0
int64_t g2 = 0xa00000002; // 0x31c0
int64_t g3 = 0xe41200e0afa0240; // 0x3b6e
int32_t g4 = 92; // 0x3e8
int64_t g5 = 0x12000000d5; // 0x400
int64_t g6 = 0x12d0; // 0x4cf8
int64_t g7 = 0x1290; // 0x4d00
int32_t g8 = 13; // 0x5144
int32_t g9 = 36; // 0x5150
int64_t g10 = 0x100000118; // 0x5230
struct _IO_FILE * g11 = NULL; // 0x5680
int64_t g12 = 0; // 0x5690
struct _IO_FILE * g13 = NULL; // 0x56a0
char g14 = 0; // 0x56a8
int32_t g15 = 0; // 0x56ab
int128_t g16; // 0x56ac
int32_t g17 = 0; // 0x56ad
char * g18; // 0x56c0
char * g19; // 0x57b0
int32_t * infile = NULL; // 0x56b0
int32_t g20;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
int32_t __fprintf_chk(struct _IO_FILE * a1, int32_t a2, char * a3, ...);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
int64_t * __memmove_chk(int64_t * a1, int64_t * a2, int32_t a3, int32_t a4);
int32_t __printf_chk(int32_t a1, char * a2, ...);
int32_t __sprintf_chk(char * a1, int32_t a2, int32_t a3, char * a4, ...);
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x4fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g20;
    }
    // 0x1016
    return result;
}

// Address range: 0x1030 - 0x1036
char * function_1030(char * name) {
    // 0x1030
    return getenv(name);
}

// Address range: 0x1040 - 0x1046
int32_t * function_1040(void) {
    // 0x1040
    return __errno_location();
}

// Address range: 0x1050 - 0x1056
char * function_1050(char * dest, char * src) {
    // 0x1050
    return strcpy(dest, src);
}

// Address range: 0x1060 - 0x1066
int32_t function_1060(char * s) {
    // 0x1060
    return puts(s);
}

// Address range: 0x1070 - 0x1076
int32_t function_1070(int32_t fd, int64_t * buf, int32_t n) {
    // 0x1070
    return write(fd, buf, n);
}

// Address range: 0x1080 - 0x1086
void function_1080(void) {
    // 0x1080
    __stack_chk_fail();
}

// Address range: 0x1090 - 0x1096
int32_t function_1090(int32_t seconds) {
    // 0x1090
    return alarm(seconds);
}

// Address range: 0x10a0 - 0x10a6
int32_t function_10a0(int32_t fd) {
    // 0x10a0
    return close(fd);
}

// Address range: 0x10b0 - 0x10b6
int32_t function_10b0(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x10b0
    return read(fd, buf, nbytes);
}

// Address range: 0x10c0 - 0x10c6
char * function_10c0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x10c0
    return fgets(s, n, stream);
}

// Address range: 0x10d0 - 0x10d6
void (*function_10d0(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x10d0
    return signal(sig, handler);
}

// Address range: 0x10e0 - 0x10e6
struct hostent * function_10e0(char * name) {
    // 0x10e0
    return gethostbyname(name);
}

// Address range: 0x10f0 - 0x10f6
int64_t * function_10f0(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen) {
    // 0x10f0
    return __memmove_chk(dest, src, len, dstlen);
}

// Address range: 0x1100 - 0x1106
int32_t function_1100(char * nptr, char ** endptr, int32_t base) {
    // 0x1100
    return strtol(nptr, endptr, base);
}

// Address range: 0x1110 - 0x1116
int32_t function_1110(struct _IO_FILE * stream) {
    // 0x1110
    return fflush(stream);
}

// Address range: 0x1120 - 0x1126
int32_t function_1120(char * s, char * format, ...) {
    // 0x1120
    return sscanf(s, format);
}

// Address range: 0x1130 - 0x1136
int32_t function_1130(int32_t flag, char * format, ...) {
    // 0x1130
    return __printf_chk(flag, format);
}

// Address range: 0x1140 - 0x1146
struct _IO_FILE * function_1140(char * filename, char * modes) {
    // 0x1140
    return fopen(filename, modes);
}

// Address range: 0x1150 - 0x1156
void function_1150(int32_t status) {
    // 0x1150
    exit(status);
}

// Address range: 0x1160 - 0x1166
int32_t function_1160(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1160
    return connect(fd, addr, len);
}

// Address range: 0x1170 - 0x1176
int32_t function_1170(struct _IO_FILE * stream, int32_t flag, char * format, ...) {
    // 0x1170
    return __fprintf_chk(stream, flag, format);
}

// Address range: 0x1180 - 0x1186
int32_t function_1180(int32_t seconds) {
    // 0x1180
    return sleep(seconds);
}

// Address range: 0x1190 - 0x1196
int16_t ** function_1190(void) {
    // 0x1190
    return __ctype_b_loc();
}

// Address range: 0x11a0 - 0x11a6
int32_t function_11a0(char * s, int32_t flag, int32_t slen, char * format, ...) {
    // 0x11a0
    return __sprintf_chk(s, flag, slen, format);
}

// Address range: 0x11b0 - 0x11b6
int32_t function_11b0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x11b0
    return socket(domain, type, protocol);
}

// Address range: 0x11c0 - 0x11c6
void function_11c0(int64_t * d) {
    // 0x11c0
    __cxa_finalize(d);
}

// Address range: 0x11d0 - 0x11ff
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x11d0
    int64_t v1; // 0x11d0
    __libc_start_main(0x12da, (int32_t)a4, (char **)&v1, (void (*)())0x2b30, (void (*)())0x2ba0, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1200 - 0x1232
int64_t deregister_tm_clones(void) {
    // 0x1200
    return (int64_t)&g11;
}

// Address range: 0x1240 - 0x1282
int64_t register_tm_clones(void) {
    // 0x1240
    return 0;
}

// Address range: 0x1290 - 0x12ca
int64_t __do_global_dtors_aux(void) {
    // 0x1290
    if (g14 != 0) {
        // 0x12c8
        int64_t result; // 0x1290
        return result;
    }
    // 0x1299
    if (*(int64_t *)0x4ff8 != 0) {
        // 0x12a7
        __cxa_finalize((int64_t *)*(int64_t *)0x5008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x12b3
    g14 = 1;
    return result2;
}

// Address range: 0x12d0 - 0x12da
int64_t frame_dummy(void) {
    // 0x12d0
    return register_tm_clones();
}

// From module:   /opt/csapp/bomblab/src/bomb.c
// Address range: 0x12da - 0x1434
// Line range:    36 - 63
int main(int argc, char ** argv) {
    if (argc == 1) {
        // 0x13dc
        *(int64_t *)&infile = g12;
    } else {
        if (argc != 2) {
            // 0x1411
            __printf_chk(1, "Usage: %s [<input_file>]\n", argv);
            exit(8);
            return &g20;
        }
        int64_t * file_path = (int64_t *)((int64_t)argv + 8); // 0x12f0
        struct _IO_FILE * file = fopen((char *)*file_path, "r"); // 0x12fb
        *(int64_t *)&infile = (int64_t)file;
        if (file == NULL) {
            // 0x13ef
            __printf_chk(1, "%s: Error: Couldn't open %s\n", "r", (char *)*file_path);
            exit(8);
            // UNREACHABLE
        }
    }
    // 0x1310
    initialize_bomb();
    puts("Welcome to my fiendish little bomb. You have 6 phases with");
    puts("which to blow yourself up. Have a nice day!");
    read_line();
    phase_1();
    phase_defused();
    puts("Phase 1 defused. How about the next one?");
    read_line();
    phase_2();
    phase_defused();
    puts("That's number 2.  Keep going!");
    read_line();
    phase_3((int64_t)&g20, (int64_t)&g20, (int64_t)&g20);
    phase_defused();
    puts("Halfway there!");
    read_line();
    phase_4();
    phase_defused();
    puts("So you got that one.  Try this one.");
    phase_5(read_line());
    phase_defused();
    puts("Good work!  On to the next...");
    read_line();
    phase_6();
    phase_defused();
    return 0;
}

// Address range: 0x1434 - 0x1454
int64_t phase_1(void) {
    // 0x1434
    int64_t v1; // 0x1434
    int64_t result = strings_not_equal(v1, "There are rumors on the internets."); // 0x143f
    if ((int32_t)result == 0) {
        // 0x1448
        return result;
    }
    // 0x144d
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x1454 - 0x14c3
int64_t phase_2(void) {
    int64_t v1 = __readfsqword(40); // 0x145a
    int32_t v2; // bp-56, 0x1454
    int64_t v3; // 0x1454
    read_six_numbers(v3, (int64_t *)&v2);
    int32_t v4; // 0x1454
    if (v4 == 1 != (v2 == 0)) {
        // 0x147f
        explode_bomb();
        // UNREACHABLE
    }
    int64_t v5 = &v2;
    int32_t v6 = 0; // 0x1499
    int64_t v7 = v5 + 4; // 0x1496
    int32_t v8 = *(int32_t *)v7; // 0x1496
    while (*(int32_t *)(v5 + 8) == v8 + v6) {
        // 0x148d
        int64_t v9; // bp-40, 0x1454
        if (v7 == (int64_t)&v9) {
            int64_t result = __readfsqword(40) ^ v1; // 0x14ac
            if (result == 0) {
                // 0x14b7
                return result;
            }
            // 0x14be
            __stack_chk_fail();
            return &g20;
        }
        v5 = v7;
        v6 = v8;
        v7 = v5 + 4;
        v8 = *(int32_t *)v7;
    }
    // 0x14a0
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x14c3 - 0x15a2
int64_t phase_3(int64_t a1, int64_t a2, int64_t a3) {
    // 0x14c3
    __readfsqword(40);
    int64_t v1; // bp-20, 0x14c3
    int64_t v2; // bp-24, 0x14c3
    int64_t str; // 0x14c3
    if (sscanf((char *)str, "%d %d", &v2, &v1) < 2) {
        // 0x150d
        explode_bomb();
        // UNREACHABLE
    }
    // 0x14f0
    if ((int32_t)v2 < 8) {
        int32_t v3 = *(int32_t *)((4 * v2 & 0x3fffffffc) + (int64_t)&g1); // 0x1504
        return (int64_t)v3 + (int64_t)&g1;
    }
    // 0x1591
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x15a2 - 0x15e1
int64_t func4(int64_t a1, int64_t a2, int64_t a3) {
    int32_t v1 = a3 - a2; // 0x15aa
    uint32_t v2 = ((int32_t)(v1 < 0) + v1 >> 1) + (int32_t)a2; // 0x15b3
    int64_t v3 = v2; // 0x15b3
    if (v3 > a1) {
        // 0x15c2
        return 2 * func4(a1, a2, (int64_t)(v2 - 1)) & 0xfffffffe;
    }
    int64_t result = 0; // 0x15c0
    if (v3 < a1) {
        // 0x15d3
        result = 2 * func4(a1, (int64_t)(v2 + 1), a3) & 0xfffffffe | 1;
    }
    // 0x15c2
    return result;
}

// Address range: 0x15e1 - 0x1656
int64_t phase_4(void) {
    int64_t v1 = __readfsqword(40); // 0x15e5
    int64_t v2; // bp-20, 0x15e1
    int64_t v3; // bp-24, 0x15e1
    int64_t str; // 0x15e1
    if (sscanf((char *)str, "%d %d", &v3, &v2) != 2 || (int32_t)v3 >= 15 || (int32_t)func4(v3 & 0xffffffff, 0, 14) != 7 || (int32_t)v2 != 7) {
        // 0x1614
        explode_bomb();
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1641
    if (result == 0) {
        // 0x164c
        return result;
    }
    // 0x1651
    __stack_chk_fail();
    return &g20;
}

// Address range: 0x1656 - 0x169c
int64_t phase_5(int64_t a1) {
    // 0x1656
    if ((int32_t)string_length(a1) != 6) {
        // 0x1695
        explode_bomb();
        // UNREACHABLE
    }
    int32_t v1 = 0; // 0x167d
    int64_t v2 = a1;
    char v3 = *(char *)v2; // 0x1677
    int32_t v4 = *(int32_t *)((int64_t)(4 * v3 & 60) + (int64_t)&g2); // 0x167d
    v1 += v4;
    int64_t result = v2 + 1; // 0x1680
    while (v2 != a1 + 5) {
        // 0x1677
        v2 = result;
        v3 = *(char *)v2;
        v4 = *(int32_t *)((int64_t)(4 * v3 & 60) + (int64_t)&g2);
        v1 += v4;
        result = v2 + 1;
    }
    if (v1 == 63) {
        // 0x1693
        return result;
    }
    // 0x168e
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x169c - 0x17e2
int64_t phase_6(void) {
    // 0x169c
    int64_t v1; // bp-136, 0x169c
    int64_t v2 = &v1; // 0x16a4
    int64_t v3 = __readfsqword(40); // 0x16a8
    int64_t v4; // 0x169c
    read_six_numbers(v4, &v1);
    int32_t v5 = *(int32_t *)&v1; // 0x16f6
    int32_t v6 = v5; // 0x1700
    int64_t v7 = v2; // 0x1700
    if (v5 >= 7) {
        // 0x16ce
        explode_bomb();
        // UNREACHABLE
    }
    int64_t v8 = 1; // 0x1702
    int64_t v9 = v8 & 0xffffffff; // 0x1702
    while ((int32_t)v8 != 6) {
        // 0x1702
        if (v6 == *(int32_t *)((0x100000000 * v9 >> 30) + v2)) {
            // 0x16e8
            explode_bomb();
            // UNREACHABLE
        }
        int64_t v10 = v9 + 1; // 0x16d5
        int64_t v11 = v10 & 0xffffffff; // 0x16db
        while ((int32_t)v10 <= 5) {
            // 0x16dd
            if (v6 == *(int32_t *)((0x100000000 * v11 >> 30) + v2)) {
                // 0x16e8
                explode_bomb();
                // UNREACHABLE
            }
            // 0x16d5
            v10 = v11 + 1;
            v11 = v10 & 0xffffffff;
        }
        // 0x16ef
        v7 += 4;
        v6 = *(int32_t *)v7;
        if (v6 >= 7) {
            // 0x16ce
            explode_bomb();
            // UNREACHABLE
        }
        v8 = v9 + 1;
        v9 = v8 & 0xffffffff;
    }
    int64_t v12 = v2; // 0x1716
    int32_t * v13 = (int32_t *)v12; // 0x171d
    *v13 = 7 - *v13;
    v12 += 4;
    int64_t v14; // bp-112, 0x169c
    while (v12 != (int64_t)&v14) {
        // 0x171b
        v13 = (int32_t *)v12;
        *v13 = 7 - *v13;
        v12 += 4;
    }
    for (int64_t i = 0; i < 6; i++) {
        int32_t v15 = *(int32_t *)(4 * i + v2); // 0x174f
        int64_t v16 = &g10; // 0x1761
        if (v15 > 1) {
            int64_t v17 = *(int64_t *)((int64_t)&g10 + 8); // 0x1735
            int64_t v18 = 2; // 0x1739
            int64_t v19 = v18 & 0xffffffff; // 0x173e
            int64_t v20 = v17; // 0x173e
            v16 = v17;
            while (v15 != (int32_t)v18) {
                // 0x1735
                v17 = *(int64_t *)(v20 + 8);
                v18 = v19 + 1;
                v19 = v18 & 0xffffffff;
                v20 = v17;
                v16 = v17;
            }
        }
        // 0x1740
        *(int64_t *)(v2 + 32 + 8 * i) = v16;
    }
    // 0x1765
    *(int64_t *)(v4 + 8) = 0;
    int32_t * v21; // 0x169c
    int64_t v22 = (int64_t)v21; // 0x17a4
    int32_t v23 = 5; // 0x17a4
    int32_t v24 = *v21; // 0x17b5
    v22 += 8;
    uint32_t v25 = *(int32_t *)v22; // 0x17b3
    while ((int64_t)v24 >= (int64_t)v25) {
        // 0x17a6
        v23--;
        if (v23 == 0) {
            int64_t result = __readfsqword(40) ^ v3; // 0x17c5
            if (result == 0) {
                // 0x17d0
                return result;
            }
            // 0x17dd
            __stack_chk_fail();
            return &g20;
        }
        v24 = v25;
        v22 += 8;
        v25 = *(int32_t *)v22;
    }
    // 0x17b9
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x17e2 - 0x1821
int64_t fun7(int64_t a1, int64_t a2) {
    // 0x17e2
    if (a1 == 0) {
        // 0x17fa
        return 0xffffffff;
    }
    if ((a1 & 0xffffffff) > a2) {
        // 0x17fa
        return 2 * fun7(*(int64_t *)(a1 + 8), a2) & 0xfffffffe;
    }
    int64_t result = 0; // 0x17f8
    if ((int32_t)a1 != (int32_t)a2) {
        // 0x180c
        result = 2 * fun7(*(int64_t *)(a1 + 16), a2) & 0xfffffffe | 1;
    }
    // 0x17fa
    return result;
}

// Address range: 0x1821 - 0x1879
int64_t secret_phase(void) {
    uint32_t str_as_l = strtol((char *)read_line(), NULL, 10); // 0x1834
    if (str_as_l - 1 > (int32_t)&g4 || (int32_t)fun7((int64_t)&g9, (int64_t)str_as_l) != 0) {
        // 0x186b
        explode_bomb();
        // UNREACHABLE
    }
    // 0x1858
    puts("Wow! You've defused the secret stage!");
    return phase_defused();
}

// Address range: 0x1879 - 0x18d5
int64_t sig_handler(void) {
    // 0x1879
    puts("So you think you can stop the bomb with ctrl-c, do you?");
    sleep(3);
    __printf_chk(1, "Well...");
    fflush(g11);
    sleep(1);
    puts("OK. :-)");
    exit(16);
    return &g20;
}

// Address range: 0x18d5 - 0x18fc
int64_t invalid_phase(int64_t a1) {
    // 0x18d5
    __printf_chk(1, "Invalid phase%s\n", (char *)a1);
    exit(8);
    return &g20;
}

// Address range: 0x18fc - 0x1919
int64_t string_length(int64_t a1) {
    // 0x18fc
    if ((char)a1 == 0) {
        // 0x1913
        return 0;
    }
    int64_t v1 = a1; // 0x18ff
    v1++;
    while (*(char *)v1 != 0) {
        // 0x1904
        v1++;
    }
    // 0x1911
    return v1 - a1 & 0xffffffff;
}

// Address range: 0x1919 - 0x1980
int64_t strings_not_equal(int64_t a1, char * a2) {
    int64_t v1 = (int64_t)a2;
    int64_t v2 = string_length(a1); // 0x1923
    if ((int32_t)v2 != (int32_t)string_length(v1)) {
        // 0x193d
        return 1;
    }
    // 0x1944
    int64_t v3; // 0x1919
    char v4 = v3;
    if (v4 == 0) {
        // 0x193d
        return 0;
    }
    int64_t v5 = a1; // 0x194e
    if ((char)v3 != v4) {
        // 0x193d
        return 1;
    }
    int64_t v6 = v1; // 0x194e
    v5++;
    char v7 = *(char *)v5; // 0x1958
    int64_t result = 0; // 0x195d
    while (v7 != 0) {
        // 0x195f
        v6++;
        result = 1;
        if (*(char *)v6 != v7) {
            // break -> 0x193d
            break;
        }
        v5++;
        v7 = *(char *)v5;
        result = 0;
    }
    // 0x193d
    return result;
}

// Address range: 0x1980 - 0x19fa
int64_t initialize_bomb(void) {
    int64_t v1 = __readfsqword(40); // 0x1987
    signal(SIGINT, 0x1879);
    int64_t v2; // bp-8216, 0x1980
    if ((int32_t)init_driver(&v2) < 0) {
        // 0x19d2
        __printf_chk(1, "Initialization error:\n%s\n", &v2);
        exit(8);
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x19bf
    if (result == 0) {
        // 0x19ca
        return result;
    }
    // 0x19f5
    __stack_chk_fail();
    return &g20;
}

// Address range: 0x19fa - 0x19fc
int64_t initialize_bomb_solve(void) {
    // 0x19fa
    int64_t result; // 0x19fa
    return result;
}

// Address range: 0x19fc - 0x1a37
int64_t blank_line(int64_t a1) {
    int64_t v1 = a1; // 0x1a02
    unsigned char v2 = *(char *)v1; // 0x1a05
    int64_t result = 1; // 0x1a0b
    while (v2 != 0) {
        int16_t * v3 = *__ctype_b_loc(); // 0x1a1a
        char v4 = *(char *)((0x100000000000000 * (int64_t)v2 >> 55 | 1) + (int64_t)v3); // 0x1a1d
        v1++;
        result = 0;
        if ((v4 & 32) == 0) {
            // break -> 0x1a30
            break;
        }
        v2 = *(char *)v1;
        result = 1;
    }
    // 0x1a30
    return result;
}

// Address range: 0x1a37 - 0x1a85
int64_t skip(void) {
    int32_t v1 = *(int32_t *)&g16; // 0x1a44
    char * str = fgets((char *)(80 * (int64_t)v1 + (int64_t)&g18), 80, (struct _IO_FILE *)infile); // 0x1a62
    while (str != NULL) {
        // 0x1a6f
        if ((int32_t)blank_line((int64_t)str) == 0) {
            // break -> 0x1a7b
            break;
        }
        v1 = *(int32_t *)&g16;
        str = fgets((char *)(80 * (int64_t)v1 + (int64_t)&g18), 80, (struct _IO_FILE *)infile);
    }
    // 0x1a7b
    return (int64_t)str;
}

// Address range: 0x1a85 - 0x1ab2
int64_t test_connection(void) {
    int64_t result = driver_ping(); // 0x1a8e
    if ((int32_t)result == 0) {
        // 0x1a97
        return result;
    }
    // 0x1a9c
    puts("Error: Cannot connect to server");
    exit(10);
    return &g20;
}

// Address range: 0x1ab2 - 0x1bd6
int64_t send_msg(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x1abd
    int64_t v2 = (int64_t)*(int32_t *)&g16; // 0x1ad0
    int64_t v3 = -1; // 0x1afc
    int64_t v4 = 16 * ((int64_t)(int32_t)&g15 + 4 * (int64_t)(int32_t)&g15) + (int64_t)&g18; // 0x1afc
    int64_t v5 = 0; // 0x1afc
    while (v3 != 0) {
        int64_t v6 = v4;
        v3--;
        bool v7; // 0x1ab2
        v4 = v6 + (v7 ? -1 : 1);
        v5 = v3;
        if (*(char *)v6 == 0) {
            // break -> 
            break;
        }
        v5 = 0;
    }
    if (-v5 >= 0x1f9f) {
        // 0x1b9a
        __printf_chk(1, "ERROR: Input string is too large.");
        exit(8);
        // UNREACHABLE
    }
    char * v8 = (int32_t)a1 == 0 ? "exploded" : "defused"; // 0x1b4e
    int64_t v9; // bp-16408, 0x1ab2
    __sprintf_chk((char *)&v9, 1, 0x2000, "%d:%s:%d:%s", (int64_t)g8, v8, v2, (char *)(16 * ((int64_t)(int32_t)&g15 + 4 * (int64_t)(int32_t)&g15) + (int64_t)&g18));
    int64_t str; // bp-8216, 0x1ab2
    int64_t v10 = driver_post("10773530", "UGXwXOdn08DTaLWKk86Y", &v9, 0, &str); // 0x1b71
    if ((int32_t)v10 < 0) {
        // 0x1bba
        puts((char *)&str);
        exit(0);
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1b86
    if (result == 0) {
        // 0x1b91
        return result;
    }
    // 0x1bd1
    __stack_chk_fail();
    return &g20;
}

// Address range: 0x1bd6 - 0x1c12
int64_t explode_bomb(void) {
    // 0x1bd6
    puts("\nBOOM!!!");
    puts("The bomb has blown up.");
    send_msg(0);
    puts("Your instructor has been notified.");
    exit(8);
    return &g20;
}

// Address range: 0x1c12 - 0x1c53
int64_t read_six_numbers(int64_t str, int64_t * a2) {
    int64_t v1 = (int64_t)a2;
    int32_t items_assigned = sscanf((char *)str, "%d %d %d %d %d %d", a2, (int64_t *)(v1 + 4), (int64_t *)(v1 + 8), (int64_t *)(v1 + 12), (int64_t *)(v1 + 16), (int64_t *)(v1 + 20)); // 0x1c3b
    if (items_assigned < 6) {
        // 0x1c4e
        return explode_bomb();
    }
    // 0x1c49
    return items_assigned;
}

// Address range: 0x1c53 - 0x1db0
int64_t read_line(void) {
    // 0x1c53
    if (skip() == 0) {
        // 0x1cee
        if (g12 == (int64_t)infile) {
            // 0x1d19
            puts("Error: Premature EOF on stdin");
            exit(8);
            // UNREACHABLE
        }
        // 0x1cfe
        if (getenv("GRADE_BOMB") != NULL) {
            // 0x1d0f
            exit(0);
            // UNREACHABLE
        }
        // 0x1d2f
        *(int64_t *)&infile = g12;
        if (skip() == 0) {
            // 0x1d50
            puts("Error: Premature EOF on stdin");
            exit(0);
            // UNREACHABLE
        }
    }
    uint32_t v1 = *(int32_t *)&g16; // 0x1c67
    int64_t v2 = v1; // 0x1c6d
    int64_t v3 = -1; // 0x1c8f
    int64_t v4 = 80 * v2 + (int64_t)&g18; // 0x1c8f
    int64_t v5 = 0; // 0x1c8f
    while (v3 != 0) {
        int64_t v6 = v4;
        v3--;
        bool v7; // 0x1c53
        v4 = v6 + (v7 ? -1 : 1);
        v5 = v3;
        if (*(char *)v6 == 0) {
            // break -> 
            break;
        }
        v5 = 0;
    }
    int64_t v8 = -2 - v5; // 0x1c9a
    if ((int32_t)v8 <= 78) {
        // 0x1ca7
        *(char *)(16 * ((0x100000000 * (int64_t)v1 >> 30) + v2) + (int64_t)&g18 + (0x100000000 * v8 - 0x100000000 >> 32)) = 0;
        test_connection();
        int32_t v9 = *(int32_t *)&g16; // 0x1cd0
        *(int32_t *)&g16 = (int32_t)&g17;
        return 80 * (int64_t)v9 + (int64_t)&g18;
    }
    // 0x1d66
    puts("Error: Input line too long");
    *(int32_t *)&g16 = (int32_t)&g17;
    int64_t v10 = 80 * (int64_t)*(int32_t *)&g16; // 0x1d83
    *(int64_t *)(v10 + (int64_t)&g18) = 0x636e7572742a2a2a;
    *(int64_t *)(v10 + (int64_t)&g18 + 8) = 0x2a2a2a64657461;
    return explode_bomb();
}

// Address range: 0x1db0 - 0x1e74
int64_t phase_defused(void) {
    int64_t v1 = __readfsqword(40); // 0x1db4
    send_msg(1);
    if (*(int32_t *)&g16 == 6) {
        // 0x1df0
        int64_t v2; // bp-104, 0x1db0
        int64_t v3; // bp-108, 0x1db0
        int64_t v4; // bp-112, 0x1db0
        int32_t items_assigned = sscanf((char *)&g19, "%d %d %s", &v4, &v3, &v2); // 0x1e12
        if (items_assigned == 3) {
            // 0x1e36
            if ((int32_t)strings_not_equal((int64_t)&v2, "DrEvil") == 0) {
                // 0x1e4b
                puts("Curses, you've found the secret phase!");
                puts("But finding it and solving it are quite different...");
                secret_phase();
            }
        }
        // 0x1e1c
        puts("Congratulations! You've defused the bomb!");
        puts("Your instructor has been notified and will verify your solution.");
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1ddc
    if (result == 0) {
        // 0x1deb
        return result;
    }
    // 0x1e6f
    __stack_chk_fail();
    return &g20;
}

// Address range: 0x1e74 - 0x1ea4
int64_t sigalrm_handler(void) {
    // 0x1e74
    __fprintf_chk(g13, 1, "Program timed out after %d seconds\n", 0);
    exit(1);
    return &g20;
}

// Address range: 0x1ea4 - 0x1f60
int64_t rio_readlineb(int64_t a1, int64_t a2, uint64_t a3) {
    int64_t v1 = a2; // 0x1ec3
    int64_t v2 = 1; // 0x1ec3
    if (a3 >= 2) {
        int64_t buf = a1 + 16; // 0x1ebb
        int32_t * v3 = (int32_t *)(a1 + 4); // 0x1ed1
        int64_t * v4 = (int64_t *)(a1 + 8);
        int64_t v5 = 1;
        int32_t v6 = *v3; // 0x1ed1
        int32_t v7 = v6; // 0x1ed6
        int64_t result; // 0x1ea4
        int64_t fd; // 0x1ea4
        int32_t v8; // 0x1ee2
        int32_t v9; // 0x1ecc
        int32_t v10; // 0x1ed1
        if (v6 >= 0 != v6 != 0) {
            v8 = read(*(int32_t *)&fd, (int64_t *)buf, 0x2000);
            *v3 = v8;
            if (v8 < 0) {
                // 0x1ec7
                v9 = *__errno_location();
                result = -1;
                if (v9 != 4) {
                    // 0x1f2f
                    return result;
                }
            } else {
                if (v8 == 0) {
                    // 0x1f4a
                    v1 = a2;
                    v2 = v5;
                    result = 0;
                    if (v5 != 1) {
                        goto lab_0x1f27;
                    } else {
                        return result;
                    }
                }
                // 0x1ef2
                *v4 = buf;
            }
            // 0x1ed1
            v10 = *v3;
            v7 = v10;
            while (v10 >= 0 != v10 != 0) {
                // 0x1ed8
                v8 = read(*(int32_t *)&fd, (int64_t *)buf, 0x2000);
                *v3 = v8;
                if (v8 < 0) {
                    // 0x1ec7
                    v9 = *__errno_location();
                    result = -1;
                    if (v9 != 4) {
                        // 0x1f2f
                        return result;
                    }
                } else {
                    if (v8 == 0) {
                        // 0x1f4a
                        v1 = a2;
                        v2 = v5;
                        result = 0;
                        if (v5 != 1) {
                            goto lab_0x1f27;
                        } else {
                            return result;
                        }
                    }
                    // 0x1ef2
                    *v4 = buf;
                }
                // 0x1ed1
                v10 = *v3;
                v7 = v10;
            }
        }
        int64_t v11 = *v4; // 0x1ef8
        char v12 = *(char *)v11; // 0x1efc
        *v4 = v11 + 1;
        *v3 = v7 - 1;
        int64_t v13 = a2 + 1; // 0x1f0d
        *(char *)a2 = v12;
        v1 = v13;
        v2 = v5;
        while (v12 != 10) {
            int64_t v14 = v5 + 1; // 0x1f1b
            int64_t v15 = v14 & 0xffffffff; // 0x1f1b
            v1 = v13;
            v2 = v15;
            if (0x100000000 * v14 >> 32 >= a3) {
                // break -> 0x1f27
                break;
            }
            v5 = v15;
            int64_t v16 = v13;
            v6 = *v3;
            v7 = v6;
            if (v6 >= 0 != v6 != 0) {
                v8 = read(*(int32_t *)&fd, (int64_t *)buf, 0x2000);
                *v3 = v8;
                if (v8 < 0) {
                    // 0x1ec7
                    v9 = *__errno_location();
                    result = -1;
                    if (v9 != 4) {
                        // 0x1f2f
                        return result;
                    }
                } else {
                    if (v8 == 0) {
                        // 0x1f4a
                        v1 = v16;
                        v2 = v5;
                        result = 0;
                        if (v5 != 1) {
                            goto lab_0x1f27;
                        } else {
                            return result;
                        }
                    }
                    // 0x1ef2
                    *v4 = buf;
                }
                // 0x1ed1
                v10 = *v3;
                v7 = v10;
                while (v10 >= 0 != v10 != 0) {
                    // 0x1ed8
                    v8 = read(*(int32_t *)&fd, (int64_t *)buf, 0x2000);
                    *v3 = v8;
                    if (v8 < 0) {
                        // 0x1ec7
                        v9 = *__errno_location();
                        result = -1;
                        if (v9 != 4) {
                            // 0x1f2f
                            return result;
                        }
                    } else {
                        if (v8 == 0) {
                            // 0x1f4a
                            v1 = v16;
                            v2 = v5;
                            result = 0;
                            if (v5 != 1) {
                                goto lab_0x1f27;
                            } else {
                                return result;
                            }
                        }
                        // 0x1ef2
                        *v4 = buf;
                    }
                    // 0x1ed1
                    v10 = *v3;
                    v7 = v10;
                }
            }
            // 0x1ef8
            v11 = *v4;
            v12 = *(char *)v11;
            *v4 = v11 + 1;
            *v3 = v7 - 1;
            v13 = v16 + 1;
            *(char *)v16 = v12;
            v1 = v13;
            v2 = v5;
        }
    }
    goto lab_0x1f27;
  lab_0x1f27:
    // 0x1f27
    *(char *)v1 = 0;
    // 0x1f2f
    return 0x100000000 * v2 >> 32;
}

// Address range: 0x1f60 - 0x27a1
int64_t submitr(char * name, int64_t * a2, char * a3, int64_t a4, int64_t a5, char * a6, int64_t a7, int64_t str2) {
    // 0x1f60
    int64_t v1; // bp-41128, 0x1f60
    int64_t v2 = &v1; // 0x1f6a
    __readfsqword(40);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1fc4
    int64_t result; // 0x1f60
    int64_t v3; // 0x1f60
    int64_t v4; // 0x1f60
    int64_t v5; // 0x1f60
    int64_t v6; // 0x1f60
    int64_t v7; // 0x1f60
    int64_t v8; // 0x20ce
    unsigned char v9; // 0x22ac
    if (sock_fd < 0) {
        // 0x2106
        *(int64_t *)str2 = 0x43203a726f727245;
        *(int64_t *)(str2 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(str2 + 16) = 0x206f7420656c6261;
        *(int64_t *)(str2 + 24) = 0x7320657461657263;
        *(int32_t *)(str2 + 32) = 0x656b636f;
        *(int16_t *)(str2 + 36) = 116;
        result = 0xffffffff;
        goto lab_0x25f0;
    } else {
        struct hostent * v10 = gethostbyname(name); // 0x1fd7
        if (v10 == NULL) {
            // 0x2156
            *(int64_t *)str2 = 0x44203a726f727245;
            *(int64_t *)(str2 + 8) = 0x6e7520736920534e;
            *(int64_t *)(str2 + 16) = 0x206f7420656c6261;
            *(int64_t *)(str2 + 24) = 0x2065766c6f736572;
            *(int64_t *)(str2 + 32) = 0x6120726576726573;
            *(int32_t *)(str2 + 40) = 0x65726464;
            *(int16_t *)(str2 + 44) = 0x7373;
            *(char *)(str2 + 46) = 0;
            close(sock_fd);
            result = 0xffffffff;
            goto lab_0x25f0;
        } else {
            int64_t v11 = (int64_t)v10; // 0x1fd7
            int64_t addr = 2; // bp-41064, 0x2002
            int64_t v12 = *(int64_t *)*(int64_t *)(v11 + 24); // 0x201b
            int64_t v13; // bp-41060, 0x1f60
            __memmove_chk(&v13, (int64_t *)v12, *(int32_t *)(v11 + 20), 12);
            if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
                // 0x21c1
                *(int64_t *)str2 = 0x55203a726f727245;
                *(int64_t *)(str2 + 8) = 0x6f7420656c62616e;
                *(int64_t *)(str2 + 16) = 0x7463656e6e6f6320;
                *(int64_t *)(str2 + 24) = 0x20656874206f7420;
                *(int32_t *)(str2 + 32) = 0x76726573;
                *(int16_t *)(str2 + 36) = 0x7265;
                *(char *)(str2 + 38) = 0;
                close(sock_fd);
                result = 0xffffffff;
                goto lab_0x25f0;
            } else {
                int64_t v14 = (int64_t)a6;
                bool v15; // 0x1f60
                v7 = v15 ? -1 : 1;
                int64_t v16 = -1; // 0x2056
                int64_t v17 = a7; // 0x1f60
                int64_t v18 = 0; // 0x2056
                while (v16 != 0) {
                    int64_t v19 = v17;
                    v16--;
                    v17 = v19 + v7;
                    v18 = v16;
                    if (*(char *)v19 == 0) {
                        // break -> 
                        break;
                    }
                    v18 = 0;
                }
                int64_t v20 = v18;
                int64_t v21 = -1; // 0x2066
                int64_t v22 = (int64_t)a3; // 0x2066
                int64_t v23 = 0; // 0x2066
                while (v21 != 0) {
                    int64_t v24 = v22;
                    v21--;
                    v22 = v24 + v7;
                    v23 = v21;
                    if (*(char *)v24 == 0) {
                        // break -> 
                        break;
                    }
                    v23 = 0;
                }
                int64_t v25 = -1; // 0x2073
                int64_t v26 = a4; // 0x2073
                int64_t v27 = 0; // 0x2073
                while (v25 != 0) {
                    int64_t v28 = v26;
                    v25--;
                    v26 = v28 + v7;
                    v27 = v25;
                    if (*(char *)v28 == 0) {
                        // break -> 
                        break;
                    }
                    v27 = 0;
                }
                int64_t v29 = -1 - v27;
                int64_t v30 = -1; // 0x2083
                int64_t v31 = v14; // 0x2083
                int64_t v32 = 0; // 0x2083
                while (v30 != 0) {
                    int64_t v33 = v31;
                    v30--;
                    v31 = v33 + v7;
                    v32 = v30;
                    if (*(char *)v33 == 0) {
                        // break -> 
                        break;
                    }
                    v32 = 0;
                }
                if (119 - v20 + (2 * v20 ^ -2) - v23 + v29 - v32 < 0x2001) {
                    // 0x20a1
                    int64_t v34; // bp-24648, 0x1f60
                    __asm_rep_stosq_memset((char *)&v34, 0, (int64_t)&g5);
                    int64_t v35 = -1; // 0x20c3
                    int64_t v36 = a7; // 0x20c3
                    int64_t v37 = 0; // 0x20c3
                    while (v35 != 0) {
                        int64_t v38 = v36;
                        v35--;
                        v36 = v38 + v7;
                        v37 = v35;
                        if (*(char *)v38 == 0) {
                            // break -> 
                            break;
                        }
                        v37 = 0;
                    }
                    v8 = -2 - v37;
                    int64_t v39 = v14; // 0x20d4
                    if ((int32_t)v8 != 0) {
                        // 0x20da
                        v6 = a7;
                        v4 = &v34;
                        while (true) {
                          lab_0x22ac:
                            // 0x22ac
                            v5 = v4;
                            v9 = *(char *)v6;
                            if (v9 < 96) {
                                if ((1 << (int64_t)((v9 + 22) % 64) & 0x2000000000ffd9) == 0) {
                                    goto lab_0x22b8;
                                } else {
                                    // 0x2297
                                    *(char *)v5 = v9;
                                    v3 = v5 + 1;
                                    goto lab_0x229f;
                                }
                            } else {
                                goto lab_0x22b8;
                            }
                        }
                      lab_0x2719:
                        // 0x2719
                        v39 = (int64_t)a6;
                    }
                    // 0x2719
                    int64_t v40; // bp-32840, 0x1f60
                    __sprintf_chk((char *)&v40, 1, 0x2000, "GET /%s/submitr.pl/?userid=%s&userpwd=%s&lab=%s&result=%s&submit=submit HTTP/1.0\r\n\r\n", a3, (char *)a4, (char *)a5, (char *)v39, &v34);
                    int64_t v41 = &v40; // 0x276a
                    int64_t v42 = -1; // 0x276d
                    int64_t v43 = v41; // 0x276d
                    int64_t v44 = 0; // 0x276d
                    while (v42 != 0) {
                        int64_t v45 = v43;
                        v42--;
                        v43 = v45 + v7;
                        v44 = v42;
                        if (*(char *)v45 == 0) {
                            // break -> 
                            break;
                        }
                        v44 = 0;
                    }
                    int64_t nbyte = -2 - v44; // 0x2775
                    int64_t buf = v41; // 0x2791
                    if (nbyte != 0) {
                        int32_t v46 = write(sock_fd, (int64_t *)buf, (int32_t)nbyte); // 0x2349
                        int64_t v47 = v46; // 0x2351
                        int32_t v48; // 0x2358
                        if (v46 >= 0 != v46 != 0) {
                            // 0x2353
                            v48 = *__errno_location();
                            v47 = 0;
                            if (v48 != 4) {
                                goto lab_0x2492;
                            }
                        }
                        int64_t v49 = nbyte - v47; // 0x233b
                        int64_t nbyte2 = v49; // 0x233e
                        buf += v47;
                        while (v49 != 0) {
                            // 0x2340
                            v46 = write(sock_fd, (int64_t *)buf, (int32_t)nbyte2);
                            v47 = v46;
                            if (v46 >= 0 != v46 != 0) {
                                // 0x2353
                                v48 = *__errno_location();
                                v47 = 0;
                                if (v48 != 4) {
                                    goto lab_0x2492;
                                }
                            }
                            // 0x2338
                            v49 = nbyte2 - v47;
                            nbyte2 = v49;
                            buf += v47;
                        }
                        if (nbyte < 0) {
                            goto lab_0x2492;
                        } else {
                            goto lab_0x236f;
                        }
                    } else {
                        goto lab_0x236f;
                    }
                } else {
                    // 0x221e
                    *(int64_t *)str2 = 0x52203a726f727245;
                    *(int64_t *)(str2 + 8) = 0x747320746c757365;
                    *(int64_t *)(str2 + 16) = 0x6f6f7420676e6972;
                    *(int64_t *)(str2 + 24) = 0x202e656772616c20;
                    *(int64_t *)(str2 + 32) = 0x6573616572636e49;
                    *(int64_t *)(str2 + 40) = 0x5254494d42555320;
                    *(int64_t *)(str2 + 48) = 0x46554258414d5f;
                    close(sock_fd);
                    result = 0xffffffff;
                    goto lab_0x25f0;
                }
            }
        }
    }
  lab_0x2492:
    // 0x2492
    *(int64_t *)str2 = 0x43203a726f727245;
    *(int64_t *)(str2 + 8) = 0x6e7520746e65696c;
    *(int64_t *)(str2 + 16) = 0x206f7420656c6261;
    *(int64_t *)(str2 + 24) = 0x6f74206574697277;
    *(int64_t *)(str2 + 32) = 0x7265732065687420;
    *(int32_t *)(str2 + 40) = 0x726576;
    close(sock_fd);
    result = 0xffffffff;
    goto lab_0x25f0;
  lab_0x22b8:
    if ((v9 & -33) < 91) {
        // 0x2297
        *(char *)v5 = v9;
        v3 = v5 + 1;
        goto lab_0x229f;
    } else {
        if (v9 == 32) {
            // 0x232b
            *(char *)v5 = 43;
            v3 = v5 + 1;
        } else {
            if (v9 > 127 == (v9 != 9)) {
                // 0x268c
                *(int64_t *)str2 = 0x52203a726f727245;
                *(int64_t *)(str2 + 8) = 0x747320746c757365;
                *(int64_t *)(str2 + 16) = 0x6e6f6320676e6972;
                *(int64_t *)(str2 + 24) = 0x6e6120736e696174;
                *(int64_t *)(str2 + 32) = 0x6c6167656c6c6920;
                *(int64_t *)(str2 + 40) = 0x72706e7520726f20;
                *(int64_t *)(str2 + 48) = 0x20656c6261746e69;
                *(int64_t *)(str2 + 56) = 0x6574636172616863;
                *(int16_t *)(str2 + 64) = 0x2e72;
                *(char *)(str2 + 66) = 0;
                close(sock_fd);
                result = 0xffffffff;
                goto lab_0x25f0;
            }
            // 0x22dd
            char v74; // bp-8264, 0x1f60
            __sprintf_chk(&v74, 1, 8, "%%%02X", (int32_t)v9);
            *(char *)v5 = v74;
            v3 = v5 + 3;
        }
        goto lab_0x229f;
    }
  lab_0x229f:;
    int64_t v75 = v6 + 1; // 0x229f
    v6 = v75;
    v4 = v3;
    if (v75 == a7 + 1 + (v8 + 0xffffffff & 0xffffffff)) {
        // break -> 0x2719
        goto lab_0x2719;
    }
    goto lab_0x22ac;
  lab_0x25f0:
    // 0x25f0
    if (*(int64_t *)(v2 + 0xa068) != __readfsqword(40)) {
        // 0x279c
        __stack_chk_fail();
        return &g20;
    }
    // 0x2607
    return result;
  lab_0x236f:;
    int64_t v50 = v2 + 80; // 0x236f
    *(int32_t *)v50 = sock_fd;
    *(int32_t *)(v2 + 84) = 0;
    *(int64_t *)(v2 + 88) = v2 + 96;
    int64_t v51 = v2 + 0x2060; // 0x238a
    if (rio_readlineb(v50, v51, 0x2000) < 1) {
        // 0x24f1
        *(int64_t *)str2 = 0x43203a726f727245;
        *(int64_t *)(str2 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(str2 + 16) = 0x206f7420656c6261;
        *(int64_t *)(str2 + 24) = 0x7269662064616572;
        *(int64_t *)(str2 + 32) = 0x6564616568207473;
        *(int64_t *)(str2 + 40) = 0x73206d6f72662072;
        *(int32_t *)(str2 + 48) = 0x65767265;
        *(int16_t *)(str2 + 52) = 114;
        close(sock_fd);
        result = 0xffffffff;
    } else {
        int64_t v52 = v2 + 60; // 0x23a5
        int64_t v53 = v2 + 0x8060; // 0x23ba
        char * str = (char *)v51; // 0x23ce
        sscanf(str, "%s %d %[a-zA-z ]", (char **)(v2 + 0x6060), (int64_t *)v52, (int64_t *)v53);
        uint32_t v54 = *(int32_t *)v52; // 0x23d3
        if (v54 != 200) {
            // 0x2565
            __sprintf_chk((char *)str2, 1, -1, "Error: HTTP request failed with error %d: %s", (int64_t)v54, (char *)v53);
            close(sock_fd);
            result = 0xffffffff;
        } else {
            int64_t v55 = 3; // 0x2404
            int64_t v56 = v51;
            int64_t v57 = (int64_t)"\r\n";
            unsigned char v58 = *(char *)v56; // 0x2404
            char v59 = *(char *)v57; // 0x2404
            char v60 = v59; // 0x2404
            bool v61 = false; // 0x2404
            int64_t v62; // 0x1f60
            int64_t v63; // 0x1f60
            while (v58 == v59) {
                v55--;
                v62 = v57 + v7;
                v63 = v56 + v7;
                v60 = v58;
                v61 = true;
                if (v55 == 0) {
                    // break -> 
                    break;
                }
                v56 = v63;
                v57 = v62;
                v58 = *(char *)v56;
                v59 = *(char *)v57;
                v60 = v59;
                v61 = false;
            }
            unsigned char v64 = v60;
            int64_t v65 = rio_readlineb(v50, v51, 0x2000);
            while ((v58 >= v64 && !v61) != v58 < v64) {
                if (v65 >= 0 != v65 != 0) {
                    // 0x2428
                    *(int64_t *)str2 = 0x43203a726f727245;
                    *(int64_t *)(str2 + 8) = 0x6e7520746e65696c;
                    *(int64_t *)(str2 + 16) = 0x206f7420656c6261;
                    *(int64_t *)(str2 + 24) = 0x6165682064616572;
                    *(int64_t *)(str2 + 32) = 0x6f72662073726564;
                    *(int64_t *)(str2 + 40) = 0x726576726573206d;
                    *(char *)(str2 + 48) = 0;
                    close(sock_fd);
                    result = 0xffffffff;
                    goto lab_0x25f0;
                }
                v55 = 3;
                v56 = v51;
                v57 = (int64_t)"\r\n";
                v58 = *(char *)v56;
                v59 = *(char *)v57;
                v60 = v59;
                v61 = false;
                while (v58 == v59) {
                    v55--;
                    v62 = v57 + v7;
                    v63 = v56 + v7;
                    v60 = v58;
                    v61 = true;
                    if (v55 == 0) {
                        // break -> 
                        break;
                    }
                    v56 = v63;
                    v57 = v62;
                    v58 = *(char *)v56;
                    v59 = *(char *)v57;
                    v60 = v59;
                    v61 = false;
                }
                v64 = v60;
                v65 = rio_readlineb(v50, v51, 0x2000);
            }
            if (v65 < 1) {
                // 0x2619
                *(int64_t *)str2 = 0x43203a726f727245;
                *(int64_t *)(str2 + 8) = 0x6e7520746e65696c;
                *(int64_t *)(str2 + 16) = 0x206f7420656c6261;
                *(int64_t *)(str2 + 24) = 0x6174732064616572;
                *(int64_t *)(str2 + 32) = 0x7373656d20737574;
                *(int64_t *)(str2 + 40) = 0x6d6f726620656761;
                *(int64_t *)(str2 + 48) = 0x72657672657320;
                close(sock_fd);
                result = 0xffffffff;
            } else {
                // 0x25b8
                strcpy((char *)str2, str);
                close(sock_fd);
                int64_t v66 = (int64_t)"OK"; // 0x1f60
                int64_t v67 = str2; // 0x1f60
                int64_t v68 = 3; // 0x25df
                unsigned char v69 = *(char *)v67; // 0x25df
                char v70 = *(char *)v66; // 0x25df
                char v71 = v70; // 0x25df
                bool v72 = false; // 0x25df
                while (v69 == v70) {
                    v68--;
                    v66 += v7;
                    v67 += v7;
                    v71 = v69;
                    v72 = true;
                    if (v68 == 0) {
                        // break -> 
                        break;
                    }
                    v69 = *(char *)v67;
                    v70 = *(char *)v66;
                    v71 = v70;
                    v72 = false;
                }
                unsigned char v73 = v71;
                result = !((v69 < v73 | v72)) != v69 < v73 ? 0xffffffff : 0;
            }
        }
    }
    goto lab_0x25f0;
}

// Address range: 0x27a1 - 0x27cc
int64_t init_timeout(int64_t a1) {
    int32_t v1 = a1; // 0x27a1
    if (v1 == 0) {
        // 0x27ca
        int64_t result; // 0x27a1
        return result;
    }
    // 0x27a5
    signal(SIGALARM, 0x1e74);
    return alarm(v1 >= 0 ? v1 : 0);
}

// Address range: 0x27cc - 0x29d5
int64_t init_driver(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = __readfsqword(40); // 0x27d7
    signal(SIGPIPE, SIG_IGN);
    signal(SIGINFO, SIG_IGN);
    signal(SIGINFO, SIG_IGN);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x2823
    int64_t result; // 0x27cc
    if (sock_fd < 0) {
        // 0x28d3
        *a1 = 0x43203a726f727245;
        *(int64_t *)(v1 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(v1 + 16) = 0x206f7420656c6261;
        *(int64_t *)(v1 + 24) = 0x7320657461657263;
        *(int32_t *)(v1 + 32) = 0x656b636f;
        *(int16_t *)(v1 + 36) = 116;
        result = 0xffffffff;
    } else {
        struct hostent * v3 = gethostbyname("200.144.254.191"); // 0x2839
        if (v3 == NULL) {
            // 0x2926
            *a1 = 0x44203a726f727245;
            *(int64_t *)(v1 + 8) = 0x6e7520736920534e;
            *(int64_t *)(v1 + 16) = 0x206f7420656c6261;
            *(int64_t *)(v1 + 24) = 0x2065766c6f736572;
            *(int64_t *)(v1 + 32) = 0x6120726576726573;
            *(int32_t *)(v1 + 40) = 0x65726464;
            *(int16_t *)(v1 + 44) = 0x7373;
            *(char *)(v1 + 46) = 0;
            close(sock_fd);
            result = 0xffffffff;
        } else {
            int64_t v4 = (int64_t)v3; // 0x2839
            int64_t addr = 2; // bp-56, 0x2860
            int64_t v5 = *(int64_t *)*(int64_t *)(v4 + 24); // 0x2877
            int64_t v6; // bp-52, 0x27cc
            __memmove_chk(&v6, (int64_t *)v5, *(int32_t *)(v4 + 20), 12);
            if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
                // 0x2998
                __sprintf_chk((char *)a1, 1, -1, "Error: Unable to connect to server %s", "200.144.254.191");
                close(sock_fd);
                result = 0xffffffff;
            } else {
                // 0x289d
                close(sock_fd);
                *(int16_t *)a1 = 0x4b4f;
                *(char *)(v1 + 2) = 0;
                result = 0;
            }
        }
    }
    // 0x28b6
    if (v2 == __readfsqword(40)) {
        // 0x28ca
        return result;
    }
    // 0x29d0
    __stack_chk_fail();
    return &g20;
}

// Address range: 0x29d5 - 0x2ab7
int64_t driver_ping(void) {
    int64_t v1 = __readfsqword(40); // 0x29db
    uint32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x29fa
    int64_t result = 0xffffffff; // 0x2a01
    if (sock_fd >= 0) {
        struct hostent * v2 = gethostbyname("200.144.254.191"); // 0x2a10
        if (v2 == NULL) {
            // 0x2a8f
            close(sock_fd);
            result = 0xffffffff;
        } else {
            int64_t v3 = (int64_t)v2; // 0x2a10
            int64_t addr = 2; // bp-56, 0x2a33
            int64_t v4 = *(int64_t *)*(int64_t *)(v3 + 24); // 0x2a4a
            int64_t v5; // bp-52, 0x29d5
            __memmove_chk(&v5, (int64_t *)v4, *(int32_t *)(v3 + 20), 12);
            int32_t v6 = connect(sock_fd, (struct sockaddr *)&addr, 16); // 0x2a63
            close(sock_fd);
            result = v6 < 0 ? 0xffffffff : 0;
        }
    }
    // 0x2a78
    if (v1 == __readfsqword(40)) {
        // 0x2a88
        return result;
    }
    // 0x2ab2
    __stack_chk_fail();
    return &g20;
}

// Address range: 0x2ab7 - 0x2b2a
int64_t driver_post(char * a1, char * a2, int64_t * a3, int64_t a4, int64_t * a5) {
    int64_t v1 = (int64_t)a5;
    if ((int32_t)a4 != 0) {
        // 0x2ad6
        __printf_chk(1, "\nAUTORESULT_STRING=%s\n", a3);
        *(int16_t *)a5 = 0x4b4f;
        *(char *)(v1 + 2) = 0;
        // 0x2ad4
        return 0;
    }
    int64_t v2 = (int64_t)a1;
    int64_t result; // 0x2ab7
    if (a1 != NULL == ((char)v2 != 0)) {
        int64_t v3 = submitr("200.144.254.191", &g3, "csapp", v2, (int64_t)a2, "pmr3309_2021", (int64_t)a3, v1); // 0x2b1f
        result = v3;
    } else {
        // 0x2ac9
        *(int16_t *)a5 = 0x4b4f;
        *(char *)(v1 + 2) = 0;
        result = a4 & 0xffffffff;
    }
    // 0x2ad4
    return result;
}

// Address range: 0x2b30 - 0x2b95
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = _init(); // 0x2b5c
    if ((int64_t)&g7 - (int64_t)&g6 >> 3 == 0) {
        // 0x2b86
        return result;
    }
    int64_t v1 = 0; // 0x2b65
    while (v1 + 1 != (int64_t)&g7 - (int64_t)&g6 >> 3) {
        // 0x2b70
        v1++;
    }
    // 0x2b86
    return result;
}

// Address range: 0x2ba0 - 0x2ba5
int64_t __libc_csu_fini(void) {
    // 0x2ba0
    int64_t result; // 0x2ba0
    return result;
}

// Address range: 0x2ba8 - 0x2bb5
int64_t _fini(void) {
    // 0x2ba8
    int64_t result; // 0x2ba8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.5.0)
// Detected functions: 66

